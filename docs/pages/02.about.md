---
title: About Reanimated
---

# 동기

---

`Animated` 라이브러리는 여러가지 한계가 있다. gesture의 상호작용 관련된 몇가지 문제가 있다.
이 프로젝트는 처음에는 screen에서 물체를 drag, snap를 하는 pan genture 상호작용 문제를 해결하기 위해 만들게 되었다.
이문제는 `Animed.event` 를 box 위치에 제스처를 mapping 하고, `useNativeDriver`를 이용하여 UI thread를 상호작용하고 있음에도, 우리는 여전히 snap Animation을 실행하기 위해서, 다시 JS로 전환해야 한다.
그 이유는 `Animated.spring({}).start()`를 선언 방식으로는 해결할 수 없기때문입니다. 왜냐하면 실행할 때, value를 업데이트 하는 `side effects`가 발생합니다.
실행 모델에 animation 노드를 넣는 작업은 매우 어렵습니다. Animation API를 업데이트하기 위해서는 frame마다 종속되어야 합니다.
우리는 필요이상으로 `side effects`를 이용하고 싶지 않습니다. 예를 들어서 animation이 여러번 실행되는 문제 등이 있습니다.

Krzysztof는 `Animated`를 재설계하여, native driver에 "Animated Tracking`을 넣는 영감(inspiration)을 하게 됩니다. 여전히, Native`Animated`라이브러리는 꽤 오랫동안 제공하고 있지 않습니다. 분명히, JS, Android 그리고 iOS 세 군데에 기능을 하나씩 넣어서 구축하는 것은 어렵다. 버그수정도 만찬가지이다. 우리 목표 중 하나는`react-native-reanimated`가 포괄적인 구성요소를 제공하여, JS에서만 보다 복잡한 기능을 구축하고, Native 코드베이스를 최대한 최소화 하는 것이다. "diffClamp"를 예를 들어보면, 3군데에`Animated` 코어에 구현되어 있고, 상당히 유용하지만, 실제로 쓰이는 케이스는 한 가지 뿐이다. ( collapsible scrollview header)

비슷한 주제로 React Native's PR [#18029](https://github.com/facebook/react-native/pull/18029) 는 적당한 사용 사례가 있지만, 관리자들은 merge하는 것을 망설이고 있다.
`Animated` API는 사람들이 이런 것을 만드는 것을 막으면 안된다. 우리의 목표는 `react-native-reanimated`는 더 낮은 수준의 접근을 가능하게 하고, 더많은 기능을 제공하는 것이다.

해당 동기에 대한 영상을 Krzysztof Magiera's [React Europe talk](https://www.youtube.com/watch?v=kdq4z2708VM) 에서 볼 수 있다.

목표:

- More generic primitive node types leading to more code reuse for the library internals therefore making it easier to add new features and fix bugs.
- 새로운 set의 base node를 `Animated` 에서 사용할 수 있도록 하는 것이다.
  - "diffClamp" 같은 복잡한 노드
  - 애니메이션 value 트랙킹이나 staggering 애니메이션 같은 상호작용
- Conditional evaluation & nodes with side effects (`set`, `startClock`, `stopClock`).
- 더이상 "“useNativeDriver” 사용하지 않아도 된다. - 모든 애니메이션을 기본적으로 UI Thread에서 작동하게 하는 것이다.

# Reanimated 개요

우리의 이 프로젝트는 완벽하게 `Animated` API와 호환하게 하는 것이다. 우리가 선택한 set of base node들로 JS에서 코드를 작성하는 것만으로도 이 작업을 수행할 수 있어야 하며, 기본 코드베이스에 큰 변화가 필요하지 않다고 믿는다. 여기에는 오리지널 `Animated` 라이브러리에 포함되지 않은 것들이 있다.
`Animated`에서 누락된 기능들이 `react-native-reanimated` 으로 구현할 수 있다. 구현방법이 다를 수 있지만, (e.g. check ["Declarative Animation API" section](declarative-animation-api.html) 에서 보고 구현하면 된다.

- [ ] value offsets 사용
- [ ] value 트랙킹 ( 다른 방법으로 사용할수 있다. `react-native-reanimated` 는 목표로 하는 params만 아니라, 모든 애니메이션의 매개변수를 추적할 수 있다. )
- [ ] animation staggering
- [ ] animation delays

# 한번의 평가 ( 알고리즘 )

하나의 frame에서 각 노드를 여러 차례 평가할 수 있었던 오리지널 `Animated`와 달리
`react-native-reanimated` 는 한 프레임에서 한 번씩 평가하도록 제한하고 있다.
side-effects가 있는 노드에는 제한이 필요하다. (e.g. [`set`](set.html) or [`startClock`](start-clock.html)).
node를 평가할 떄 (e.g. [`add`](add.html) 경우에 입력 노드의 합계를 얻으려고 함.) 값을 캐시한다. 다음 프레임 내에서 평가하는 대신에 cache된 값을 반환한다. 이러한 개념은 적은 수의 노드를 평가하려고 시도할 수 있기 때문에 성능 개선에 도움이 된다. 평가할 노드의 결정을 위한 알고리즘은 다음과 같다.

1.  매 프레임에 대해 먼저 생성된 events를 우리는 분석한다.( 예 touch stream). event가 일부 애니메이션의 값을 업데이트 할수 있다.
2.  그리고 나서, "작동중인" 노드에 대해서 [clock](clock-and-the-algorithm.html) 다음과 같이 업데이트 한다.
3.  업데이트 노트에서 시작하여, 노드의 트리를 돌고, view에 연결된 최종 노드를 찾는다.
4.  view 속성과 연결된 노드를 발견하면, 해당 노드를 평가한다. 이는 입력 노드 등에 대한 평가를 재귀적으로 트리거할 수 있다.
5.  모든 것이 끝난 후, "running" 상태인지 확인한다. 만약 그렇다면 다음 프레임으로 평가될 콜백을 요청하고 다시 1번부터 다시 시작한다. 그렇지 않으면 아무것도 하지 않는다.

# 100% 선언적 gesture 상호작용

[Gesture Handler](https://kmagiera.github.io/react-native-gesture-handler) `react-native-reanimated` 와 가장 잘 어울리다. [ImagePreview app](https://github.com/software-mansion/react-native-reanimated/blob/master/Example/imageViewer)를 포함한 예시들은, 해당 라이브러리를 이용해서 만든다.
