---
title: About Reanimated
---

# 동기

---

`Animated` 라이브러리는 여러가지 한계가 있다. gesture의 상호작용 관련된 몇가지 문제가 있다.
이 프로젝트는 처음에는 screen에서 물체를 drag, snap를 하는 pan genture 상호작용 문제를 해결하기 위해 만들게 되었다.
이문제는 `Animed.event` 를 box 위치에 제스처를 mapping 하고, `useNativeDriver`를 이용하여 UI thread를 상호작용하고 있음에도, 우리는 여전히 snap Animation을 실행하기 위해서, 다시 JS로 전환해야 한다.
그 이유는 `Animated.spring({}).start()`를 선언 방식으로는 해결할 수 없기때문입니다. 왜냐하면 실행할 때, value를 업데이트 하는 `side effects`가 발생합니다.
실행 모델에 animation 노드를 넣는 작업은 매우 어렵습니다. Animation API를 업데이트하기 위해서는 frame마다 종속되어야 합니다.
우리는 필요이상으로 `side effects`를 이용하고 싶지 않습니다. 예를 들어서 animation이 여러번 실행되는 문제 등이 있습니다.

Krzysztof는 `Animated`를 재설계하여, native driver에 "Animated Tracking`을 넣는 영감(inspiration)을 하게 됩니다. 여전히, Native`Animated`라이브러리는 꽤 오랫동안 제공하고 있지 않습니다. 분명히, JS, Android 그리고 iOS 세 군데에 기능을 하나씩 넣어서 구축하는 것은 어렵다. 버그수정도 만찬가지이다. 우리 목표 중 하나는`react-native-reanimated`가 포괄적인 구성요소를 제공하여, JS에서만 보다 복잡한 기능을 구축하고, Native 코드베이스를 최대한 최소화 하는 것이다. "diffClamp"를 예를 들어보면, 3군데에`Animated` 코어에 구현되어 있고, 상당히 유용하지만, 실제로 쓰이는 케이스는 한 가지 뿐이다. ( collapsible scrollview header)

비슷한 주제로 React Native's PR [#18029](https://github.com/facebook/react-native/pull/18029) 는 적당한 사용 사례가 있지만, 관리자들은 merge하는 것을 망설이고 있다.
`Animated` API는 사람들이 이런 것을 만드는 것을 막으면 안된다. 우리의 목표는 `react-native-reanimated`는 더 낮은 수준의 접근을 가능하게 하고, 더많은 기능을 제공하는 것이다.

해당 동기에 대한 영상을 Krzysztof Magiera's [React Europe talk](https://www.youtube.com/watch?v=kdq4z2708VM) 에서 볼 수 있다.

The goals:

- More generic primitive node types leading to more code reuse for the library internals therefore making it easier to add new features and fix bugs.
- The new set of base nodes can be used to implement `Animated` compatible API including:
  - Complex nodes such as “diffClamp”.
  - Interactions such as animated value tracking or animation staggering.
- Conditional evaluation & nodes with side effects (`set`, `startClock`, `stopClock`).
- No more “useNativeDriver” – all animations runs on the UI thread by default

# Reanimated overview

We aim to bring this project to be fully compatible with `Animated` API. We believe that the set of base nodes we have selected should make this possible to be done only by writing JS code and does not require significant changes in the native codebases. Here is a list of things that haven't yet been ported from the original version of `Animated` library.
All the functionality that missing elements provide in `Animated` can already be achieved with `react-native-reanimated` although a different methodology for implementing those may be required (e.g. check ["Declarative Animation API" section](declarative-animation-api.html) to see how the implementation may differ).

- [ ] using value offsets
- [ ] value tracking (can be achieved in different way, `react-native-reanimated` also allows for tracking all the animation parameters not only destination params)
- [ ] animation staggering
- [ ] animation delays

# At most once evaluation (the algorithm)

Unlike the original `Animated` library where each node could have been evaluated many times within a single frame, `react-native-reanimated` restricts each node to be evaluated at most once in a frame.
This restriction is required for nodes that have side-effects to be used (e.g. [`set`](set.html) or [`startClock`](start-clock.html)).
When node is evaluated (e.g. in case of an [`add`](add.html) node we want to get a sum of the input nodes) its value is cached. If within the next frame there are other nodes that want to use the output of that node instead of evaluating we return cached value.
This notion also helps with performance as we can try to evaluate as few nodes as expected.
The current algorithm for making decisions of which nodes to evaluate works as follows:

1.  For each frame we first analyze the generated events (e.g. touch stream). It is possible that events may update some animated values.
2.  Then we update values that correspond to [clock](clock-and-the-algorithm.html) nodes that are "running".
3.  We traverse the node's tree starting from the nodes that have been updated in the current cycle and we look for final nodes that are connected to views.
4.  If we found nodes connected to view properties we evaluate them. This can recursively trigger an evaluation for their input nodes etc.
5.  After everything is done we check if some "running" clocks exists. If so we enqueue a callback to be evaluated with the next frame and start over from pt 1. Otherwise we do nothing.

# 100% declarative gesture interactions

`react-native-reanimated` works best with the [Gesture Handler](https://kmagiera.github.io/react-native-gesture-handler)
library. Currently all the examples are made using that library, including the ultimate
[ImagePreview app](https://github.com/software-mansion/react-native-reanimated/blob/master/Example/imageViewer).
